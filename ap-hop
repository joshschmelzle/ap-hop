#!/usr/bin/env bash
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ap-hop - Aruba New Central "Jump-to-AP" SSH tool
#
# Quickly "hop" into the access point by providing a client MAC or AP BSSID
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

set -euo pipefail

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Constants
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

readonly VERSION="0.0.3"
readonly SCRIPT_NAME="ap-hop"
readonly DEFAULT_SSH_USER="admin"
readonly DEFAULT_SSH_TIMEOUT=10

readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_CONFIG_ERROR=2
readonly EXIT_API_ERROR=3
readonly EXIT_SSH_ERROR=4
readonly EXIT_VALIDATION_ERROR=5
readonly EXIT_DEPENDENCY_ERROR=6

# Order matters for menu display
readonly DEFAULT_CLUSTERS='# Aruba New Central API Gateway Clusters
# Format: NAME|URL|TYPE
# Lines starting with # are comments
# Order determines menu display order
Internal2|https://internal.api.central.arubanetworks.com|Private
EU-1|https://de1.api.central.arubanetworks.com|Public
EU-Central2|https://de2.api.central.arubanetworks.com|Public
EU-Central3|https://de3.api.central.arubanetworks.com|Public
UK-West2|https://gb1.api.central.arubanetworks.com|Public
US-1|https://us1.api.central.arubanetworks.com|Public
US-2|https://us2.api.central.arubanetworks.com|Public
US-West4|https://us4.api.central.arubanetworks.com|Public
US-West5|https://us5.api.central.arubanetworks.com|Public
US-East1|https://us6.api.central.arubanetworks.com|Public
Canada-1|https://ca1.api.central.arubanetworks.com|Public
APAC-1|https://in.api.central.arubanetworks.com|Public
APAC-East1|https://jp1.api.central.arubanetworks.com|Public
APAC-South1|https://au1.api.central.arubanetworks.com|Public
UAE-North1|https://ae1.api.central.arubanetworks.com|Public'

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Global variables
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VERBOSE=false
DRY_RUN=false
NON_INTERACTIVE=false
PROFILE=""
CONFIG_DIR=""
CONFIG_FILE=""
CLUSTERS_FILE=""
SSH_USER=""
SITE_FILTER=""
SITE_ID_FILTER=""
VERIFY_AP_STATUS=false
AP_NAME=""
AP_MAC=""
AP_IP=""
LIST_SITES=false
REFRESH_SITES=false
LIST_APS=false
REFRESH_APS=false
SHOW_ALL_SITES=false

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Utility functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_config_dir() {
    echo "${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_NAME"
}

log_info() {
    echo "$*"
}

log_error() {
    echo "Error: $*" >&2
}

# Log verbose message to stderr (only if VERBOSE=true)
log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo "$*" >&2
    fi
}

check_dependencies() {
    local missing=()

    for cmd in curl jq sshpass; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing[*]}"
        log_error "Please install them and try again."
        exit "$EXIT_DEPENDENCY_ERROR"
    fi
}

is_valid_json() {
    echo "$1" | jq -e . &>/dev/null
}

ensure_config_dir() {
    CONFIG_DIR="$(get_config_dir)"
    CONFIG_FILE="$CONFIG_DIR/config"
    CLUSTERS_FILE="$CONFIG_DIR/clusters"

    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
        chmod 700 "$CONFIG_DIR"
    fi
}

# Ensure clusters file exists with defaults
ensure_clusters_file() {
    if [[ ! -f "$CLUSTERS_FILE" ]]; then
        echo "$DEFAULT_CLUSTERS" > "$CLUSTERS_FILE"
        chmod 644 "$CLUSTERS_FILE"
    fi
}

ensure_config_file() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
[_settings]
default_profile=default
ssh_timeout=10
EOF
        chmod 600 "$CONFIG_FILE"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Site cache functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_sites_cache_file() {
    echo "$CONFIG_DIR/sites_cache"
}

is_sites_cache_valid() {
    local cache_file
    cache_file=$(get_sites_cache_file)

    if [[ ! -f "$cache_file" ]]; then
        return 1
    fi

    local cache_time current_time age
    if [[ "$(uname -s)" == "Darwin" ]]; then
        cache_time=$(stat -f %m "$cache_file" 2>/dev/null)
    else
        cache_time=$(stat -c %Y "$cache_file" 2>/dev/null)
    fi
    current_time=$(date +%s)
    age=$((current_time - cache_time))

    [[ $age -gt 86400 ]] && return 1 || return 0
}

fetch_and_cache_sites() {
    local endpoint="/network-monitoring/v1alpha1/sites-health"

    log_verbose "Fetching sites from API..."

    local response
    response=$(api_get "$endpoint") || {
        log_error "Failed to fetch sites"
        return 1
    }

    local cache_file
    cache_file=$(get_sites_cache_file)

    {
        echo "# Sites cache - $(date)"
        echo "# Format: SITE_ID|SITE_NAME|CLIENT_COUNT|DEVICE_COUNT"
        echo "$response" | jq -r '.items[] | "\(.id)|\(.name)|\(.clients.count)|\(.devices.count)"'
    } > "$cache_file"

    local count
    count=$(grep -c -v '^#' "$cache_file")
    log_verbose "Cached $count sites"
    return 0
}

load_cached_sites() {
    local cache_file
    cache_file=$(get_sites_cache_file)

    if [[ ! -f "$cache_file" ]]; then
        SITE_IDS=()
        SITE_NAMES=()
        SITE_CLIENT_COUNTS=()
        SITE_DEVICE_COUNTS=()
        return 1
    fi

    SITE_IDS=()
    SITE_NAMES=()
    SITE_CLIENT_COUNTS=()
    SITE_DEVICE_COUNTS=()

    while IFS='|' read -r site_id site_name client_count device_count; do
        [[ "$site_id" =~ ^# ]] && continue
        SITE_IDS+=("$site_id")
        SITE_NAMES+=("$site_name")
        SITE_CLIENT_COUNTS+=("$client_count")
        SITE_DEVICE_COUNTS+=("${device_count:-0}")
    done < <(grep -v '^#' "$cache_file")

    return 0
}

invalidate_sites_cache() {
    rm -f "$(get_sites_cache_file)"
    log_verbose "Sites cache invalidated"
}

find_site_by_name() {
    local search_name="$1"

    for ((i=0; i<${#SITE_NAMES[@]}; i++)); do
        if [[ "${SITE_NAMES[$i]}" == "$search_name" ]]; then
            echo "${SITE_IDS[$i]}"
            return 0
        fi
    done

    return 1
}

find_site_by_id() {
    local search_id="$1"

    for ((i=0; i<${#SITE_IDS[@]}; i++)); do
        if [[ "${SITE_IDS[$i]}" == "$search_id" ]]; then
            echo "${SITE_NAMES[$i]}"
            return 0
        fi
    done

    return 1
}

# Sets: SELECTED_SITE_ID, SELECTED_SITE_NAME, SELECTED_SITE_CLIENT_COUNT
select_site() {
    local filtered_indices=()
    local hidden_count=0

    if [[ -z "${SITE_IDS[*]:-}" ]] || [[ -z "${SITE_NAMES[*]:-}" ]] || [[ -z "${SITE_CLIENT_COUNTS[*]:-}" ]]; then
        log_error "Site data not loaded properly"
        exit "$EXIT_ERROR"
    fi

    for ((i=0; i<${#SITE_IDS[@]}; i++)); do
        if [[ "${SITE_CLIENT_COUNTS[$i]}" -gt 0 ]] || [[ "$SHOW_ALL_SITES" == true ]]; then
            filtered_indices+=("$i")
        else
            hidden_count=$((hidden_count + 1))
        fi
    done

    if [[ ${#filtered_indices[@]} -eq 1 ]] && [[ "$SHOW_ALL_SITES" != true ]]; then
        local idx="${filtered_indices[0]}"
        SELECTED_SITE_ID="${SITE_IDS[$idx]}"
        SELECTED_SITE_NAME="${SITE_NAMES[$idx]}"
        SELECTED_SITE_CLIENT_COUNT="${SITE_CLIENT_COUNTS[$idx]}"
        log_info "Auto-selected site: $SELECTED_SITE_NAME (${SITE_CLIENT_COUNTS[$idx]} clients)" >&2
        return
    fi

    if [[ ${#filtered_indices[@]} -eq 0 ]]; then
        log_error "No sites with clients found. Use --all to see all sites or refresh the cache."
        exit "$EXIT_ERROR"
    fi

    echo "" >&2
    echo "Select site to search:" >&2
    echo "" >&2

    for ((j=0; j<${#filtered_indices[@]}; j++)); do
        local orig_idx="${filtered_indices[$j]}"
        printf "  %2d) %-35s (%3d clients)\n" \
            "$((j+1))" "${SITE_NAMES[$orig_idx]}" "${SITE_CLIENT_COUNTS[$orig_idx]}" >&2
    done

    echo "   r) Refresh site cache" >&2

    if [[ $hidden_count -gt 0 ]]; then
        echo "" >&2
        echo "Note: $hidden_count sites have 0 clients (use --all to show or refresh the site cache)" >&2
    fi

    echo "" >&2

    local selection
    read -r -p "Enter selection: " selection

    if [[ "$selection" =~ ^[Rr]$ ]]; then
        SELECTED_SITE_ID="__REFRESH__"
        return
    fi

    if [[ ! "$selection" =~ ^[0-9]+$ ]] || \
       (( selection < 1 || selection > ${#filtered_indices[@]} )); then
        log_error "Invalid selection"
        exit "$EXIT_ERROR"
    fi

    local filtered_idx=$((selection - 1))
    local orig_idx="${filtered_indices[$filtered_idx]}"
    SELECTED_SITE_ID="${SITE_IDS[$orig_idx]}"
    SELECTED_SITE_NAME="${SITE_NAMES[$orig_idx]}"
    SELECTED_SITE_CLIENT_COUNT="${SITE_CLIENT_COUNTS[$orig_idx]}"
}

sanitize_site_name() {
    local site_name="$1"
    echo "$site_name" | tr ' ' '_' | sed 's/[^a-zA-Z0-9_-]//g'
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# AP cache functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_aps_cache_file() {
    local site_id="$1"
    local site_name="$2"
    local sanitized
    sanitized=$(sanitize_site_name "$site_name")
    echo "$CONFIG_DIR/aps_cache_${sanitized}"
}

is_aps_cache_valid() {
    local site_id="$1"
    local site_name="$2"
    local cache_file
    cache_file=$(get_aps_cache_file "$site_id" "$site_name")

    [[ ! -f "$cache_file" ]] && return 1

    local cache_time current_time age
    # Get modification time in epoch format (cross-platform)
    if [[ "$(uname -s)" == "Darwin" ]]; then
        cache_time=$(stat -f %m "$cache_file" 2>/dev/null)
    else
        cache_time=$(stat -c %Y "$cache_file" 2>/dev/null)
    fi
    current_time=$(date +%s)
    age=$((current_time - cache_time))

    [[ $age -gt 86400 ]] && return 1 || return 0
}

invalidate_aps_cache() {
    local site_id="$1"
    local site_name="$2"
    rm -f "$(get_aps_cache_file "$site_id" "$site_name")"
    log_verbose "AP cache invalidated for site: $site_name"
}

fetch_and_cache_aps() {
    local site_id="$1"
    local site_name="$2"
    local cache_file
    cache_file=$(get_aps_cache_file "$site_id" "$site_name")
    local max_aps="${MAX_APS_PER_SITE:-1000}"

    log_info "Building AP cache for '$site_name'..."

    local all_aps=""
    local offset=0
    local limit=100
    local total_fetched=0

    while true; do
        local endpoint="/network-monitoring/v1alpha1/aps?site-id=${site_id}&limit=${limit}&offset=${offset}"
        local response
        response=$(api_get "$endpoint") || {
            log_error "Failed to fetch APs for site"
            return 1
        }

        local online_aps
        online_aps=$(echo "$response" | jq -r '.items[] | select(.status == "ONLINE") | .serialNumber')

        if [[ -z "$online_aps" ]]; then
            break
        fi

        all_aps="${all_aps}${online_aps}"$'\n'
        total_fetched=$((total_fetched + $(echo "$online_aps" | wc -l | xargs)))

        local next
        next=$(echo "$response" | jq -r '.next // empty')
        if [[ -z "$next" ]] || [[ $total_fetched -ge $max_aps ]]; then
            break
        fi

        offset=$((offset + limit))
    done

    all_aps=$(echo "$all_aps" | grep -v '^$')
    local ap_count
    ap_count=$(echo "$all_aps" | wc -l | xargs)

    if [[ $ap_count -eq 0 ]]; then
        log_error "No online APs found in site '$site_name'"
        return 1
    fi

    log_info "Found $ap_count online APs, fetching details..."

    local processed=0
    local start_time
    start_time=$(date +%s)

    {
        echo "# APs cache for site: $site_name - $(date)"
        echo "# Format: SERIAL|NAME|MAC|IP|BSSID1,BSSID2,BSSID3,..."

        while IFS= read -r serial; do
            [[ -z "$serial" ]] && continue

            local ap_response
            ap_response=$(api_get "/network-monitoring/v1alpha1/aps/${serial}" 2>/dev/null) || {
                log_verbose "Warning: Failed to fetch details for AP $serial"
                processed=$((processed + 1))
                continue
            }

            local name mac ip
            name=$(echo "$ap_response" | jq -r '.deviceName // "Unknown"')
            mac=$(echo "$ap_response" | jq -r '.macAddress // "Unknown"')
            ip=$(echo "$ap_response" | jq -r '.ipv4 // empty')

            [[ -z "$ip" ]] && {
                log_verbose "Warning: AP $serial has no IP address, skipping"
                processed=$((processed + 1))
                continue
            }

            local bssids
            bssids=$(echo "$ap_response" | jq -r '[.radios[]? | .wlans[]? | .bssid] | join(",")')

            echo "${serial}|${name}|${mac}|${ip}|${bssids}"

            processed=$((processed + 1))

            if (( processed % 10 == 0 )); then
                echo "Progress: $processed/$ap_count APs cached..." >&2
            fi

        done <<< "$all_aps"
    } > "$cache_file"

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    local cached_count
    cached_count=$(grep -c -v '^#' "$cache_file")

    if [[ $cached_count -eq 0 ]]; then
        log_error "Failed to cache any APs for site '$site_name'"
        rm -f "$cache_file"
        return 1
    fi

    if [[ $cached_count -lt $ap_count ]]; then
        log_info "Warning: Only cached $cached_count/$ap_count APs (some failed to fetch)"
    fi

    log_info "Cache built in ${duration}s ($cached_count APs cached)"
    return 0
}

find_serial_by_bssid_cached() {
    local bssid="$1"
    local site_id="$2"
    local site_name="$3"
    local cache_file
    cache_file=$(get_aps_cache_file "$site_id" "$site_name")
    local normalized_bssid
    normalized_bssid=$(normalize_mac "$bssid")

    while IFS='|' read -r serial name mac ip bssids; do
        [[ "$serial" =~ ^# ]] && continue

        if echo ",$bssids," | grep -q ",${normalized_bssid},"; then
            echo "${serial}|${name}|${mac}|${ip}"
            return 0
        fi
    done < <(grep -v '^#' "$cache_file")

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# INI file functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

read_ini_value() {
    local file="$1"
    local section="$2"
    local key="$3"

    if [[ ! -f "$file" ]]; then
        return 1
    fi

    awk -F '=' -v section="$section" -v key="$key" '
        /^\[/ {
            current_section = substr($0, 2, length($0) - 2)
        }
        current_section == section && $1 == key {
            # Handle values with = in them
            sub(/^[^=]*=/, "")
            print
            exit
        }
    ' "$file"
}

ini_section_exists() {
    local file="$1"
    local section="$2"

    if [[ ! -f "$file" ]]; then
        return 1
    fi

    grep -q "^\[$section\]$" "$file"
}

write_ini_value() {
    local file="$1"
    local section="$2"
    local key="$3"
    local value="$4"
    local temp_file

    temp_file=$(mktemp)

    if [[ ! -f "$file" ]]; then
        echo "[$section]" > "$file"
        echo "$key=$value" >> "$file"
        chmod 600 "$file"
        rm -f "$temp_file"
        return 0
    fi

    if ! ini_section_exists "$file" "$section"; then
        cp "$file" "$temp_file"
        {
            echo ""
            echo "[$section]"
            echo "$key=$value"
        } >> "$temp_file"
        mv "$temp_file" "$file"
        return 0
    fi

    awk -v section="$section" -v key="$key" -v value="$value" '
        BEGIN { in_section = 0; key_found = 0 }
        /^\[/ {
            if (in_section && !key_found) {
                print key "=" value
                key_found = 1
            }
            in_section = (substr($0, 2, length($0) - 2) == section)
        }
        in_section && index($0, key "=") == 1 {
            print key "=" value
            key_found = 1
            next
        }
        { print }
        END {
            if (in_section && !key_found) {
                print key "=" value
            }
        }
    ' "$file" > "$temp_file"

    mv "$temp_file" "$file"
}

delete_ini_section() {
    local file="$1"
    local section="$2"
    local temp_file

    if [[ ! -f "$file" ]]; then
        return 0
    fi

    temp_file=$(mktemp)

    awk -v section="$section" '
        /^\[/ {
            current_section = substr($0, 2, length($0) - 2)
        }
        current_section != section { print }
    ' "$file" > "$temp_file"

    mv "$temp_file" "$file"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Profile functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_default_profile() {
    local default
    default=$(read_ini_value "$CONFIG_FILE" "_settings" "default_profile")
    echo "${default:-default}"
}

set_default_profile() {
    local profile="$1"
    local old_profile
    old_profile=$(get_default_profile)

    write_ini_value "$CONFIG_FILE" "_settings" "default_profile" "$profile"

    # Invalidate sites cache when switching to a different profile
    if [[ -n "$old_profile" && "$old_profile" != "$profile" ]]; then
        invalidate_sites_cache
        log_verbose "Switched from profile '$old_profile' to '$profile', sites cache invalidated"
    fi
}

get_ssh_timeout() {
    local timeout
    timeout=$(read_ini_value "$CONFIG_FILE" "_settings" "ssh_timeout")
    echo "${timeout:-$DEFAULT_SSH_TIMEOUT}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Last found site tracking (for fast-path optimization)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_last_found_site_id() {
    local profile="$1"
    read_ini_value "$CONFIG_FILE" "$profile" "last_found_site_id"
}

get_last_found_site_name() {
    local profile="$1"
    read_ini_value "$CONFIG_FILE" "$profile" "last_found_site_name"
}

update_last_found_site() {
    local profile="$1"
    local site_id="$2"
    local site_name="$3"
    local timestamp
    timestamp=$(date +%s)

    write_ini_value "$CONFIG_FILE" "$profile" "last_found_site_id" "$site_id"
    write_ini_value "$CONFIG_FILE" "$profile" "last_found_site_name" "$site_name"
    write_ini_value "$CONFIG_FILE" "$profile" "last_found_timestamp" "$timestamp"

    log_verbose "Updated last found site: $site_name (ID: $site_id)"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Profile management
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


list_profiles() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        return
    fi

    grep '^\[' "$CONFIG_FILE" | sed 's/\[\(.*\)\]/\1/' | grep -v '^_settings$' || true
}

profile_exists() {
    local profile="$1"
    ini_section_exists "$CONFIG_FILE" "$profile"
}

validate_profile() {
    local profile="$1"
    local missing=()

    for field in cluster client_id client_secret; do
        local value
        value=$(read_ini_value "$CONFIG_FILE" "$profile" "$field")
        if [[ -z "$value" ]]; then
            missing+=("$field")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Profile '$profile' is missing required fields: ${missing[*]}"
        log_error "Run 'ap-hop config --profile $profile' to configure."
        return 1
    fi

    return 0
}

# Sets: CLUSTER, CLUSTER_URL, CLIENT_ID, CLIENT_SECRET, ACCESS_TOKEN, TOKEN_TIMESTAMP, SSH_PASSWORD, SSH_USER
load_profile() {
    local profile="$1"

    if ! profile_exists "$profile"; then
        # Check if any profiles exist at all
        local existing_profiles
        existing_profiles=$(list_profiles)
        if [[ -z "$existing_profiles" ]]; then
            log_info "No profiles configured. Let's create your first profile."
            echo ""
            interactive_config "$profile" "true"
            echo ""
            log_info "Configuration complete! Continuing..."
            echo ""
            # Reload the profile after creation
            load_profile "$profile"
            return
        else
            log_error "Profile '$profile' does not exist."
            log_error "Run 'ap-hop config --profile $profile' to create it, or use --profile to specify an existing one."
            exit "$EXIT_CONFIG_ERROR"
        fi
    fi

    if ! validate_profile "$profile"; then
        exit "$EXIT_CONFIG_ERROR"
    fi

    CLUSTER=$(read_ini_value "$CONFIG_FILE" "$profile" "cluster")
    CLIENT_ID=$(read_ini_value "$CONFIG_FILE" "$profile" "client_id")
    CLIENT_SECRET=$(read_ini_value "$CONFIG_FILE" "$profile" "client_secret")
    ACCESS_TOKEN=$(read_ini_value "$CONFIG_FILE" "$profile" "access_token")
    TOKEN_TIMESTAMP=$(read_ini_value "$CONFIG_FILE" "$profile" "token_timestamp")
    SSH_PASSWORD=$(read_ini_value "$CONFIG_FILE" "$profile" "ssh_password")
    SSH_USER=$(read_ini_value "$CONFIG_FILE" "$profile" "ssh_user")
    SSH_USER="${SSH_USER:-$DEFAULT_SSH_USER}"
    MAX_APS_PER_SITE=$(read_ini_value "$CONFIG_FILE" "$profile" "max_aps_per_site")
    MAX_APS_PER_SITE="${MAX_APS_PER_SITE:-1000}"

    CLUSTER_URL=$(get_cluster_url "$CLUSTER")
    if [[ -z "$CLUSTER_URL" ]]; then
        if [[ "$CLUSTER" == http* ]]; then
            CLUSTER_URL="$CLUSTER"
        else
            log_error "Unknown cluster '$CLUSTER'. Check your clusters file."
            exit "$EXIT_CONFIG_ERROR"
        fi
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cluster functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_cluster_url() {
    local name="$1"

    if [[ ! -f "$CLUSTERS_FILE" ]]; then
        return 1
    fi

    grep -v '^#' "$CLUSTERS_FILE" | grep -v '^$' | while IFS='|' read -r cluster_name url _type; do
        if [[ "$cluster_name" == "$name" ]]; then
            echo "$url"
            return 0
        fi
    done
}

list_clusters() {
    if [[ ! -f "$CLUSTERS_FILE" ]]; then
        echo "$DEFAULT_CLUSTERS" | grep -v '^#' | grep -v '^$'
    else
        grep -v '^#' "$CLUSTERS_FILE" | grep -v '^$'
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Interactive config functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

select_cluster() {
    local existing="${1:-}"
    local clusters=()
    local urls=()
    local types=()
    local i=1
    local default_selection=1

    echo "" >&2
    echo "Select Aruba New Central cluster:" >&2
    echo "" >&2

    while IFS='|' read -r name url type; do
        clusters+=("$name")
        urls+=("$url")
        types+=("$type")

        # If this matches the existing cluster, make it the default
        if [[ "$name" == "$existing" ]]; then
            default_selection=$i
        fi

        if [[ "$type" == "Private" ]]; then
            printf "  %2d) %-14s %s [Private]\n" "$i" "$name" "$url" >&2
        else
            printf "  %2d) %-14s %s\n" "$i" "$name" "$url" >&2
        fi
        ((i++))
    done < <(list_clusters)

    echo "   c) Custom URL" >&2
    echo "" >&2

    local selection
    read -r -p "Enter selection [$default_selection]: " selection
    selection="${selection:-$default_selection}"

    if [[ "$selection" == "c" || "$selection" == "C" ]]; then
        local custom_url
        read -r -p "Enter custom cluster URL: " custom_url
        echo "$custom_url"
    elif [[ "$selection" =~ ^[0-9]+$ ]] && (( selection >= 1 && selection <= ${#clusters[@]} )); then
        echo "${clusters[$((selection-1))]}"
    else
        log_error "Invalid selection"
        exit "$EXIT_ERROR"
    fi
}

prompt_value() {
    local prompt="$1"
    local default="${2:-}"
    local required="${3:-false}"
    local value

    if [[ -n "$default" ]]; then
        read -r -p "$prompt [$default]: " value
        value="${value:-$default}"
    else
        read -r -p "$prompt: " value
    fi

    if [[ "$required" == "true" && -z "$value" ]]; then
        log_error "This field is required."
        exit "$EXIT_ERROR"
    fi

    echo "$value"
}

interactive_config() {
    local profile="$1"
    local force_edit="${2:-false}"
    local existing_cluster="" existing_client_id=""
    local existing_client_secret="" existing_ssh_user="" existing_ssh_password=""
    local is_first_profile=false

    # Check if this is the first profile being created
    local existing_profiles
    existing_profiles=$(list_profiles)
    if [[ -z "$existing_profiles" ]]; then
        is_first_profile=true
    fi

    if profile_exists "$profile" && [[ "$force_edit" != "true" ]]; then
        echo ""
        echo "'$profile' is currently the active profile."
        echo ""
        echo "To view:       $SCRIPT_NAME config --show"
        echo "To edit:       $SCRIPT_NAME config --profile $profile"
        echo "To switch:     $SCRIPT_NAME config --use <name>"
        echo "To list all:   $SCRIPT_NAME config --list"
        echo ""
        read -r -p "Create a new profile? Enter name (or press Enter to cancel): " new_profile_name

        if [[ -z "$new_profile_name" ]]; then
            echo "Cancelled."
            return
        fi

        # Recurse with the new profile name
        interactive_config "$new_profile_name" "false"
        return
    fi

    echo ""
    echo "Configuring profile: $profile"

    if profile_exists "$profile"; then
        existing_cluster=$(read_ini_value "$CONFIG_FILE" "$profile" "cluster")
        existing_client_id=$(read_ini_value "$CONFIG_FILE" "$profile" "client_id")
        existing_client_secret=$(read_ini_value "$CONFIG_FILE" "$profile" "client_secret")
        existing_ssh_user=$(read_ini_value "$CONFIG_FILE" "$profile" "ssh_user")
        existing_ssh_password=$(read_ini_value "$CONFIG_FILE" "$profile" "ssh_password")
        existing_max_aps_per_site=$(read_ini_value "$CONFIG_FILE" "$profile" "max_aps_per_site")
    fi

    local cluster
    cluster=$(select_cluster "$existing_cluster")

    local client_id client_secret ssh_user ssh_password max_aps_per_site

    client_id=$(prompt_value "Client ID" "$existing_client_id" "true")
    client_secret=$(prompt_value "Client Secret" "$existing_client_secret" "true")
    ssh_user=$(prompt_value "SSH Username" "${existing_ssh_user:-$DEFAULT_SSH_USER}")
    ssh_password=$(prompt_value "SSH Password (optional, Enter to skip)" "$existing_ssh_password")
    max_aps_per_site=$(prompt_value "Max APs per site for cache" "${existing_max_aps_per_site:-1000}")

    write_ini_value "$CONFIG_FILE" "$profile" "cluster" "$cluster"
    write_ini_value "$CONFIG_FILE" "$profile" "client_id" "$client_id"
    write_ini_value "$CONFIG_FILE" "$profile" "client_secret" "$client_secret"
    write_ini_value "$CONFIG_FILE" "$profile" "ssh_user" "$ssh_user"
    write_ini_value "$CONFIG_FILE" "$profile" "ssh_password" "$ssh_password"
    write_ini_value "$CONFIG_FILE" "$profile" "max_aps_per_site" "$max_aps_per_site"

    echo ""
    echo "Configuration saved."

    # If this is the first profile, automatically set it as default
    if [[ "$is_first_profile" == true ]]; then
        set_default_profile "$profile"
        echo "Default profile set to: $profile"
        return
    fi

    # Ask to set as default if not already
    local current_default
    current_default=$(get_default_profile)

    if [[ "$current_default" != "$profile" ]]; then
        local set_default
        read -r -p "Set '$profile' as default profile? [y/N]: " set_default
        if [[ "$set_default" =~ ^[Yy]$ ]]; then
            set_default_profile "$profile"
            echo "Default profile set to: $profile"
        fi
    fi
}

# Mask a sensitive values, showing only first 4 and last 4 characters
mask_value() {
    local value="$1"
    local len=${#value}

    if [[ -z "$value" ]]; then
        echo "(not set)"
    elif [[ $len -le 8 ]]; then
        echo "********"
    else
        echo "${value:0:4}$(printf '*%.0s' $(seq 1 $((len - 8))))${value: -4}"
    fi
}

# Usage: show_config <profile> [unmask]
show_config() {
    local profile="$1"
    local unmask="${2:-false}"
    local default_profile
    default_profile=$(get_default_profile)

    if ! profile_exists "$profile"; then
        log_error "Profile '$profile' does not exist."
        exit "$EXIT_CONFIG_ERROR"
    fi

    local cluster client_id client_secret access_token token_timestamp ssh_user ssh_password max_aps_per_site
    cluster=$(read_ini_value "$CONFIG_FILE" "$profile" "cluster")
    client_id=$(read_ini_value "$CONFIG_FILE" "$profile" "client_id")
    client_secret=$(read_ini_value "$CONFIG_FILE" "$profile" "client_secret")
    access_token=$(read_ini_value "$CONFIG_FILE" "$profile" "access_token")
    token_timestamp=$(read_ini_value "$CONFIG_FILE" "$profile" "token_timestamp")
    ssh_user=$(read_ini_value "$CONFIG_FILE" "$profile" "ssh_user")
    ssh_user="${ssh_user:-$DEFAULT_SSH_USER}"
    ssh_password=$(read_ini_value "$CONFIG_FILE" "$profile" "ssh_password")
    max_aps_per_site=$(read_ini_value "$CONFIG_FILE" "$profile" "max_aps_per_site")
    max_aps_per_site="${max_aps_per_site:-1000}"

    local cluster_url
    cluster_url=$(get_cluster_url "$cluster")
    if [[ -z "$cluster_url" && "$cluster" == http* ]]; then
        cluster_url="$cluster"
    fi

    local ssh_timeout
    ssh_timeout=$(get_ssh_timeout)

    echo ""
    if [[ "$profile" == "$default_profile" ]]; then
        echo "Profile: $profile (active)"
    else
        echo "Profile: $profile"
    fi

    if [[ -n "$cluster_url" ]]; then
        echo "Cluster:       $cluster ($cluster_url)"
    else
        echo "Cluster:       $cluster"
    fi
    echo "Client ID:     ${client_id:-(not set)}"

    if [[ "$unmask" == "true" ]]; then
        echo "Client Secret: ${client_secret:-(not set)}"
        echo "Access Token:  ${access_token:-(not set)}"
        if [[ -n "$token_timestamp" ]]; then
            echo "Token Time:    $(date -d "@$token_timestamp" 2>/dev/null || date -r "$token_timestamp" 2>/dev/null || echo "$token_timestamp")"
        else
            echo "Token Time:    (not set)"
        fi
        echo "SSH Username:  $ssh_user"
        echo "SSH Password:  ${ssh_password:-(not set)}"
        echo "Max APs/site:  $max_aps_per_site"
    else
        echo "Client Secret: $(mask_value "$client_secret")"
        echo "Access Token:  $(mask_value "$access_token")"
        if [[ -n "$token_timestamp" ]]; then
            echo "Token Time:    $(date -d "@$token_timestamp" 2>/dev/null || date -r "$token_timestamp" 2>/dev/null || echo "$token_timestamp")"
        else
            echo "Token Time:    (not set)"
        fi
        echo "SSH Username:  $ssh_user"
        if [[ -n "$ssh_password" ]]; then
            echo "SSH Password:  ********"
        else
            echo "SSH Password:  (not set)"
        fi
        echo "Max APs/site:  $max_aps_per_site"
    fi

    echo "SSH Timeout:   ${ssh_timeout}s"
    echo ""
    echo "Config file: $CONFIG_FILE"
    if [[ "$unmask" != "true" ]]; then
        echo "Use --unmask to show sensitive values"
    fi
    echo ""
}

# List all profiles with indication of active
cmd_config_list() {
    local default_profile profiles
    default_profile=$(get_default_profile)
    profiles=$(list_profiles)

    if [[ -z "$profiles" ]]; then
        echo ""
        echo "No profiles configured."
        echo "Run 'ap-hop config' to create one."
        echo ""
        return
    fi

    echo ""
    echo "Available profiles:"

    while read -r profile; do
        if [[ "$profile" == "$default_profile" ]]; then
            echo "  * $profile (active)"
        else
            echo "    $profile"
        fi
    done <<< "$profiles"

    echo ""
}

cmd_config() {
    local show=false
    local list=false
    local unmask=false
    local delete=false
    local use_profile=""
    local config_profile=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --show)
                show=true
                shift
                ;;
            --unmask)
                unmask=true
                shift
                ;;
            --list)
                list=true
                shift
                ;;
            --delete)
                delete=true
                shift
                ;;
            --use)
                if [[ -z "${2:-}" ]]; then
                    log_error "--use requires a profile name"
                    exit "$EXIT_ERROR"
                fi
                use_profile="$2"
                shift 2
                ;;
            --profile|-p)
                if [[ -z "${2:-}" ]]; then
                    log_error "--profile requires a profile name"
                    exit "$EXIT_ERROR"
                fi
                config_profile="$2"
                shift 2
                ;;
            --help|-h)
                show_config_help
                exit "$EXIT_SUCCESS"
                ;;
            *)
                log_error "Unknown config option: $1"
                show_config_help
                exit "$EXIT_ERROR"
                ;;
        esac
    done

    # Handle --list
    if [[ "$list" == true ]]; then
        cmd_config_list
        return
    fi

    # Handle --delete (requires --profile)
    if [[ "$delete" == true ]]; then
        if [[ -z "$config_profile" ]]; then
            log_error "--delete requires --profile <name>"
            exit "$EXIT_ERROR"
        fi

        if ! profile_exists "$config_profile"; then
            log_error "Profile '$config_profile' does not exist."
            exit "$EXIT_CONFIG_ERROR"
        fi

        # Check if it's the active profile
        local current_default
        current_default=$(get_default_profile)

        if [[ "$config_profile" == "$current_default" ]]; then
            log_error "Cannot delete the active profile."
            log_error "Use '$SCRIPT_NAME config --use <other_profile>' to switch first."
            exit "$EXIT_ERROR"
        fi

        # Confirm deletion
        local confirm
        read -r -p "Delete profile '$config_profile'? [y/N]: " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            return
        fi

        delete_ini_section "$CONFIG_FILE" "$config_profile"
        echo "Profile '$config_profile' deleted."
        return
    fi

    # Handle --use
    if [[ -n "$use_profile" ]]; then
        if ! profile_exists "$use_profile"; then
            log_error "Profile '$use_profile' does not exist."
            exit "$EXIT_CONFIG_ERROR"
        fi
        set_default_profile "$use_profile"
        echo "Default profile set to: $use_profile"
        return
    fi

    # Determine which profile to work with and whether user explicitly specified it
    local target_profile
    local explicit_profile=false
    if [[ -n "$config_profile" ]]; then
        target_profile="$config_profile"
        explicit_profile=true
    elif [[ -n "$PROFILE" ]]; then
        target_profile="$PROFILE"
        explicit_profile=true
    else
        target_profile=$(get_default_profile)
    fi

    # Handle --show
    if [[ "$show" == true ]]; then
        show_config "$target_profile" "$unmask"
        return
    fi

    # Default: interactive configuration
    # Pass explicit_profile so we know if user wants to edit an existing profile
    interactive_config "$target_profile" "$explicit_profile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MAC address functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

validate_mac() {
    local mac="$1"

    local clean_mac
    clean_mac=$(echo "$mac" | tr -d ':.-' | tr '[:upper:]' '[:lower:]')

    [[ "$clean_mac" =~ ^[0-9a-f]{12}$ ]]
}

normalize_mac() {
    local mac="$1"

    local clean_mac
    clean_mac=$(echo "$mac" | tr -d ':.-' | tr '[:upper:]' '[:lower:]')

    echo "$clean_mac" | sed 's/\(..\)/\1:/g' | sed 's/:$//'
}

get_local_wifi_mac() {
    local os_type
    os_type=$(uname -s)

    case "$os_type" in
        Darwin)
            # macOS - Use networksetup to find Wi-Fi interface (fast: ~28ms)
            local wifi_iface
            wifi_iface=$(networksetup -listallhardwareports 2>/dev/null | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')

            if [[ -z "$wifi_iface" ]]; then
                return 1
            fi

            local status
            status=$(ifconfig "$wifi_iface" 2>/dev/null | grep "status:" | awk '{print $2}')

            if [[ "$status" != "active" ]]; then
                return 1
            fi

            if ! ifconfig "$wifi_iface" 2>/dev/null | grep -q "inet "; then
                return 1
            fi

            local wifi_mac
            wifi_mac=$(ifconfig "$wifi_iface" 2>/dev/null | grep "ether" | awk '{print $2}')

            if [[ -n "$wifi_mac" ]]; then
                echo "$wifi_mac"
                return 0
            fi
            ;;

        Linux)
            local iw_output
            iw_output=$(iw dev 2>/dev/null)

            if [[ -z "$iw_output" ]]; then
                return 1
            fi

            local current_mac=""
            local has_ssid=false

            while IFS= read -r line; do
                if [[ "$line" =~ Interface[[:space:]]([a-zA-Z0-9]+) ]]; then
                    if [[ -n "$current_mac" && "$has_ssid" == true ]]; then
                        echo "$current_mac"
                        return 0
                    fi

                    current_mac=""
                    has_ssid=false

                elif [[ "$line" =~ addr[[:space:]]([0-9a-fA-F:]+) ]]; then
                    current_mac="${BASH_REMATCH[1]}"

                elif [[ "$line" =~ ssid[[:space:]](.+) ]]; then
                    has_ssid=true
                fi
            done <<< "$iw_output"

            if [[ -n "$current_mac" && "$has_ssid" == true ]]; then
                echo "$current_mac"
                return 0
            fi
            ;;
    esac

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# OAuth2 functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

generate_access_token() {
    local url="https://sso.common.cloud.hpe.com/as/token.oauth2"

    log_verbose "Generating access token..."

    local response http_code
    response=$(curl -s -w "\n%{http_code}" \
        -X POST "$url" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "grant_type=client_credentials&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET")

    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    if [[ "$http_code" != "200" ]]; then
        log_error "Token generation failed (HTTP $http_code)"
        log_verbose "Response: $response"
        return 1
    fi

    NEW_ACCESS_TOKEN=$(echo "$response" | jq -r '.access_token // empty')

    if [[ -z "$NEW_ACCESS_TOKEN" ]]; then
        log_error "Token generation response missing access_token"
        log_verbose "Response: $response"
        return 1
    fi

    return 0
}

update_token() {
    local profile="$1"
    local access_token="$2"
    local timestamp
    timestamp=$(date +%s)

    write_ini_value "$CONFIG_FILE" "$profile" "access_token" "$access_token"
    write_ini_value "$CONFIG_FILE" "$profile" "token_timestamp" "$timestamp"

    # Update global variables
    ACCESS_TOKEN="$access_token"
    TOKEN_TIMESTAMP="$timestamp"

    log_verbose "Token updated in config with timestamp $timestamp"
}

is_token_expired() {
    local token_timestamp="${TOKEN_TIMESTAMP:-0}"
    local current_time
    current_time=$(date +%s)
    local age=$((current_time - token_timestamp))

    [[ $age -gt 720 ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Smart site search functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Try to find MAC in the last known site (fast-path)
# Returns 0 if found, 1 if not found
# Sets global variables: AP_SERIAL, SITE_ID, SITE_NAME when found
try_last_found_site() {
    local mac="$1"
    local last_site_id="$2"
    local last_site_name="$3"

    log_verbose "Checking last known location: $last_site_name..."

    # Try as client first (without timeout - the API should respond quickly if site is correct)
    local client_response
    if client_response=$(get_client_by_mac "$mac" "$last_site_id" 2>/dev/null); then
        local ap_serial
        ap_serial=$(echo "$client_response" | jq -r '.connectedDeviceSerial // empty')

        if [[ -n "$ap_serial" ]]; then
            # Found as client!
            AP_SERIAL="$ap_serial"
            SITE_ID="$last_site_id"
            SITE_NAME="$last_site_name"
            log_verbose "Found in last location (as client)"
            return 0
        fi
    fi

    # Try as BSSID if we have cached APs for this site
    if is_aps_cache_valid "$last_site_id" "$last_site_name"; then
        local cache_file
        cache_file=$(get_aps_cache_file "$last_site_id" "$last_site_name")

        local found_line
        found_line=$(grep -i "$mac" "$cache_file" 2>/dev/null | grep -v '^#' | head -n1)

        if [[ -n "$found_line" ]]; then
            # Found as BSSID!
            AP_SERIAL=$(echo "$found_line" | cut -d'|' -f1)
            SITE_ID="$last_site_id"
            SITE_NAME="$last_site_name"
            log_verbose "Found in last location (as BSSID)"
            return 0
        fi
    fi

    log_verbose "Not in last location"
    return 1
}

# Auto-search for MAC across all sites
# Phase 1: Search as client in sites with >0 clients
# Phase 2: Search as BSSID in sites with existing AP cache
# Returns 0 if found, 1 if not found
# Sets global variables: AP_SERIAL, SITE_ID, SITE_NAME when found
auto_search_all_sites() {
    local mac="$1"
    local start_time
    start_time=$(date +%s)
    local search_started=false
    local show_progress=false

    # Count sites to search
    local sites_with_clients=0
    for ((i=0; i<${#SITE_IDS[@]}; i++)); do
        if [[ "${SITE_CLIENT_COUNTS[$i]}" -gt 0 ]]; then
            ((sites_with_clients++))
        fi
    done

    # Start progress display in background after 3 seconds
    (
        sleep 3
        # Check if search is still running
        if kill -0 $$ 2>/dev/null; then
            echo "" >&2
        fi
    ) &
    local progress_pid=$!

    log_info "Searching for $mac..."

    # Phase 1: Search as CLIENT (sites with >0 clients)
    for ((i=0; i<${#SITE_IDS[@]}; i++)); do
        local site_id="${SITE_IDS[$i]}"
        local site_name="${SITE_NAMES[$i]}"
        local client_count="${SITE_CLIENT_COUNTS[$i]}"

        # Skip sites with 0 clients
        if [[ "$client_count" -eq 0 ]]; then
            continue
        fi

        # Show progress if > 3 seconds have elapsed
        local elapsed=$(($(date +%s) - start_time))
        if [[ $elapsed -ge 3 ]]; then
            show_progress=true
        fi

        if [[ "$show_progress" == true ]]; then
            local mins=$((elapsed / 60))
            local secs=$((elapsed % 60))
            log_info "$(printf '[%02d:%02d]' $mins $secs) Checking site '$site_name' ($client_count clients)..."
        fi

        # Try to find client
        local client_response
        if client_response=$(get_client_by_mac "$mac" "$site_id" 2>/dev/null); then
            local ap_serial
            ap_serial=$(echo "$client_response" | jq -r '.connectedDeviceSerial // empty')

            if [[ -n "$ap_serial" ]]; then
                # Found!
                kill $progress_pid 2>/dev/null
                wait $progress_pid 2>/dev/null

                AP_SERIAL="$ap_serial"
                SITE_ID="$site_id"
                SITE_NAME="$site_name"

                if [[ "$show_progress" == true ]]; then
                    log_info "$(printf '[%02d:%02d]' $mins $secs) Found in site '$site_name'!"
                    echo ""
                fi

                return 0
            fi
        fi
    done

    # Phase 2: Search as BSSID (sites with existing AP cache only)
    if [[ "$show_progress" == true ]]; then
        log_info "Not found as client. Searching as AP BSSID in cached sites..."
    fi

    for ((i=0; i<${#SITE_IDS[@]}; i++)); do
        local site_id="${SITE_IDS[$i]}"
        local site_name="${SITE_NAMES[$i]}"
        local device_count="${SITE_DEVICE_COUNTS[$i]}"

        # Skip sites with 0 devices and 0 clients
        if [[ "$device_count" -eq 0 && "${SITE_CLIENT_COUNTS[$i]}" -eq 0 ]]; then
            continue
        fi

        # Only search if AP cache exists
        if ! is_aps_cache_valid "$site_id" "$site_name"; then
            continue
        fi

        local elapsed=$(($(date +%s) - start_time))
        if [[ $elapsed -ge 3 ]]; then
            show_progress=true
        fi

        if [[ "$show_progress" == true ]]; then
            local mins=$((elapsed / 60))
            local secs=$((elapsed % 60))
            log_info "$(printf '[%02d:%02d]' $mins $secs) Checking APs in '$site_name'..."
        fi

        local cache_file
        cache_file=$(get_aps_cache_file "$site_id" "$site_name")

        local found_line
        found_line=$(grep -i "$mac" "$cache_file" 2>/dev/null | grep -v '^#' | head -n1)

        if [[ -n "$found_line" ]]; then
            # Found!
            kill $progress_pid 2>/dev/null
            wait $progress_pid 2>/dev/null

            AP_SERIAL=$(echo "$found_line" | cut -d'|' -f1)
            SITE_ID="$site_id"
            SITE_NAME="$site_name"

            if [[ "$show_progress" == true ]]; then
                local mins=$((elapsed / 60))
                local secs=$((elapsed % 60))
                log_info "$(printf '[%02d:%02d]' $mins $secs) Found in site '$site_name'!"
                echo ""
            fi

            return 0
        fi
    done

    # Not found
    kill $progress_pid 2>/dev/null
    wait $progress_pid 2>/dev/null

    if [[ "$show_progress" == true ]]; then
        echo ""
    fi

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# API functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

api_get() {
    local endpoint="$1"
    local url="$CLUSTER_URL$endpoint"
    local max_retries=3
    local retry_count=0
    local auth_retry_count=0
    local max_auth_retries=3

    # Check if token needs refresh before making request
    if is_token_expired; then
        log_verbose "Token expired or expiring soon, generating new token..."
        if generate_access_token; then
            update_token "$CURRENT_PROFILE" "$NEW_ACCESS_TOKEN"
            log_verbose "New token generated successfully"
        else
            log_error "Failed to generate access token. Check your credentials."
            exit "$EXIT_API_ERROR"
        fi
    fi

    while true; do
        local headers=(-H "Authorization: Bearer $ACCESS_TOKEN" \
                       -H "Content-Type: application/json" \
                       -H "cache-control: no-cache")

        log_verbose "GET $url"

        local response http_code
        response=$(curl -s -w "\n%{http_code}" -X GET "$url" "${headers[@]}")
        http_code=$(echo "$response" | tail -n1)
        response=$(echo "$response" | sed '$d')

        log_verbose "HTTP $http_code"

        if [[ "$http_code" == "401" ]]; then
            ((auth_retry_count++))

            if [[ $auth_retry_count -gt $max_auth_retries ]]; then
                log_error "Authentication failed after $max_auth_retries token refresh attempts."
                log_error ""
                log_error "We successfully generated a valid access token, but the endpoint is rejecting it."
                log_error "This might mean the cluster URL is incorrect or has changed."
                log_error ""
                log_error "Current configuration:"
                log_error "  Profile: $CURRENT_PROFILE"
                log_error "  Cluster URL: $CLUSTER_URL"
                log_error "  Endpoint: $endpoint"
                exit "$EXIT_API_ERROR"
            fi

            log_verbose "Received 401, attempting to generate new token... (attempt $auth_retry_count/$max_auth_retries)"

            if generate_access_token; then
                update_token "$CURRENT_PROFILE" "$NEW_ACCESS_TOKEN"
                log_verbose "New token generated, retrying request..."
                continue
            else
                log_error "Authentication failed. Check your credentials or run 'ap-hop config' to reconfigure."
                exit "$EXIT_API_ERROR"
            fi
        fi

        if [[ "$http_code" == "429" ]]; then
            ((retry_count++))
            if [[ $retry_count -ge $max_retries ]]; then
                log_error "Rate limit exceeded. Please try again later."
                exit "$EXIT_API_ERROR"
            fi
            log_verbose "Rate limited, waiting 1 second... (attempt $retry_count/$max_retries)"
            sleep 1
            continue
        fi

        # Handle connection failures (HTTP 000 means curl couldn't connect)
        if [[ "$http_code" == "000" ]] || [[ "$http_code" =~ ^0 ]]; then
            log_error "Failed to connect to the cluster endpoint."
            log_error ""
            log_error "This may indicate:"
            log_error "  - DNS resolution failure (hostname doesn't exist)"
            log_error "  - Network connectivity issue"
            log_error "  - Incorrect cluster URL"
            log_error ""
            log_error "Current configuration:"
            log_error "  Profile: $CURRENT_PROFILE"
            log_error "  Cluster URL: $CLUSTER_URL"
            log_error "  Endpoint: $endpoint"
            log_error "  Full URL: $url"
            exit "$EXIT_API_ERROR"
        fi

        if [[ "$http_code" != "200" ]]; then
            echo "$response"
            return "$http_code"
        fi

        log_verbose "Response body length: ${#response} bytes"

        echo "$response"
        return 0
    done
}

get_client_by_mac() {
    local mac="$1"
    local site_id="$2"

    local encoded_mac="${mac//:/%3A}"

    local endpoint="/network-monitoring/v1alpha1/clients/${encoded_mac}?site-id=${site_id}"

    api_get "$endpoint"
}

get_serial_by_bssid() {
    local bssid="$1"
    local site_id="$2"
    local site_name="$3"

    if ! is_aps_cache_valid "$site_id" "$site_name"; then
        if ! fetch_and_cache_aps "$site_id" "$site_name"; then
            echo "Failed to build AP cache for site '$site_name'" >&2
            return 1
        fi
    fi

    local result
    result=$(find_serial_by_bssid_cached "$bssid" "$site_id" "$site_name") || {
        echo "BSSID not found in cache" >&2
        return 1
    }

    local serial name mac ip
    IFS='|' read -r serial name mac ip <<< "$result"

    if [[ "$VERIFY_AP_STATUS" == true ]]; then
        echo "Verifying AP status..." >&2
        local ap_response
        ap_response=$(api_get "/network-monitoring/v1alpha1/aps/${serial}" 2>/dev/null) || {
            echo "Warning: Failed to verify AP status" >&2
        }

        if [[ -n "$ap_response" ]]; then
            local current_ip
            current_ip=$(echo "$ap_response" | jq -r '.ipv4 // empty')
            if [[ -n "$current_ip" && "$current_ip" != "$ip" ]]; then
                echo "Note: AP IP changed from $ip to $current_ip" >&2
                ip="$current_ip"
            fi

            local status
            status=$(echo "$ap_response" | jq -r '.status // "Unknown"')
            if [[ "$status" != "ONLINE" ]]; then
                echo "Warning: AP status is '$status'" >&2
            fi
        fi
    fi

    AP_NAME="$name"
    AP_MAC="$mac"
    AP_IP="$ip"

    echo "$serial"
    return 0
}

get_ap_by_serial() {
    local serial="$1"
    local endpoint="/network-monitoring/v1alpha1/aps/$serial"

    api_get "$endpoint"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# SSH functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

get_ssh_password() {
    # Check config
    if [[ -n "$SSH_PASSWORD" ]]; then
        echo "$SSH_PASSWORD"
        return
    fi

    # Check environment variable
    if [[ -n "${ARUBA_SSH_PASSWORD:-}" ]]; then
        echo "$ARUBA_SSH_PASSWORD"
        return
    fi

    # Prompt user
    local password
    read -r -s -p "SSH Password: " password
    echo >&2  # Newline after password prompt
    echo "$password"
}

ssh_to_ap() {
    local ip="$1"
    local password="$2"
    local timeout
    timeout=$(get_ssh_timeout)

    log_info "Connecting..."
    log_verbose "sshpass -e ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=$timeout -o LogLevel=ERROR $SSH_USER@$ip"

    local ssh_exit_code
    SSHPASS="$password" sshpass -e ssh \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o ConnectTimeout="$timeout" \
        -o LogLevel=ERROR \
        "$SSH_USER@$ip"
    ssh_exit_code=$?

    # sshpass exit code 5 = invalid/incorrect password
    if [[ $ssh_exit_code -eq 5 ]]; then
        log_error "SSH authentication failed. Is the password correct?"
        log_error "Update with: $SCRIPT_NAME config --profile $CURRENT_PROFILE"
    fi

    return $ssh_exit_code
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Main workflow
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmd_lookup() {
    local input="$1"

    # Validate input is MAC/BSSID format
    if ! validate_mac "$input"; then
        log_error "Invalid MAC/BSSID format: $input"
        log_error "Accepted formats: aa:bb:cc:dd:ee:ff, aa-bb-cc-dd-ee-ff, aabbccddeeff"
        exit "$EXIT_VALIDATION_ERROR"
    fi

    local normalized_input
    normalized_input=$(normalize_mac "$input")

    # Load profile
    CURRENT_PROFILE="${PROFILE:-$(get_default_profile)}"
    load_profile "$CURRENT_PROFILE"

    log_verbose "Using profile: $CURRENT_PROFILE"
    log_verbose "Cluster: $CLUSTER ($CLUSTER_URL)"

    # === SITE CACHE MANAGEMENT ===

    # Check cache validity
    if ! is_sites_cache_valid; then
        log_info "Site cache expired or missing, fetching sites..."
        if ! fetch_and_cache_sites "$CURRENT_PROFILE"; then
            log_error "Failed to fetch sites from API"
            exit "$EXIT_API_ERROR"
        fi
    fi

    # Load sites into memory
    if ! load_cached_sites; then
        log_error "Failed to load sites cache"
        exit "$EXIT_ERROR"
    fi

    # === SITE SELECTION ===

    local site_id site_name site_client_count ap_serial lookup_method goto_ap_details
    site_id=""
    site_name=""
    ap_serial=""
    lookup_method=""
    goto_ap_details=false

    if [[ -n "$SITE_ID_FILTER" ]]; then
        # User provided --site-id
        site_id="$SITE_ID_FILTER"
        site_name=$(find_site_by_id "$site_id")

        if [[ -z "$site_name" ]]; then
            log_error "Site ID '$site_id' not found in cache"
            log_error "Run '$SCRIPT_NAME --list-sites' to see available sites"
            exit "$EXIT_ERROR"
        fi

        log_verbose "Using site: $site_name (ID: $site_id)"

    elif [[ -n "$SITE_FILTER" ]]; then
        # User provided --site <name>
        site_id=$(find_site_by_name "$SITE_FILTER")

        if [[ -z "$site_id" ]]; then
            log_error "Site '$SITE_FILTER' not found in cache"
            log_error "Run '$SCRIPT_NAME --list-sites' to see available sites"
            exit "$EXIT_ERROR"
        fi

        site_name="$SITE_FILTER"
        log_verbose "Using site: $site_name (ID: $site_id)"

    else
        # No site specified - use smart auto-search

        # Try last found site first (fast path)
        local last_site_id last_site_name
        last_site_id=$(get_last_found_site_id "$CURRENT_PROFILE")
        last_site_name=$(get_last_found_site_name "$CURRENT_PROFILE")

        if [[ -n "$last_site_id" && -n "$last_site_name" ]]; then
            if try_last_found_site "$normalized_input" "$last_site_id" "$last_site_name"; then
                # Found in last site! Update timestamp and proceed
                update_last_found_site "$CURRENT_PROFILE" "$SITE_ID" "$SITE_NAME"
                site_id="$SITE_ID"
                site_name="$SITE_NAME"
                ap_serial="$AP_SERIAL"

                log_info ""
                log_info "Found in site: $site_name"
                log_info ""

                # Skip to AP details lookup
                lookup_method="FASTPATH"
                goto_ap_details=true
            else
                log_verbose "Not in last location, searching all sites..."
            fi
        fi

        # Not found in last site (or no last site), auto-search all sites
        if [[ -z "$site_id" ]]; then
            if auto_search_all_sites "$normalized_input"; then
                # Found! Update last found site
                update_last_found_site "$CURRENT_PROFILE" "$SITE_ID" "$SITE_NAME"
                site_id="$SITE_ID"
                site_name="$SITE_NAME"
                ap_serial="$AP_SERIAL"

                log_info "Found in site: $site_name"
                log_info ""

                # Skip to AP details lookup
                lookup_method="AUTOSEARCH"
                goto_ap_details=true
            else
                # Not found anywhere - offer options
                echo ""
                log_error "MAC address $normalized_input not found in any site."
                echo ""

                # Read from terminal if available and interactive mode is enabled
                local response="N"
                if [[ "$NON_INTERACTIVE" == false ]]; then
                    echo "Options:"
                    echo "  r) Refresh sites cache and search again"
                    echo "  m) Manually select a site to search"
                    echo "  n) Exit"
                    echo ""

                    if [[ -t 0 ]]; then
                        read -r -p "Choose an option [r/m/N]: " response
                        echo ""
                    elif [[ -e /dev/tty ]]; then
                        read -r -p "Choose an option [r/m/N]: " response < /dev/tty
                        echo ""
                    fi
                fi

                if [[ "$response" =~ ^[Rr]$ ]]; then
                    # Refresh and retry
                    log_info "Refreshing sites cache..."
                    invalidate_sites_cache
                    fetch_and_cache_sites "$CURRENT_PROFILE"
                    load_cached_sites

                    log_info "Searching again..."
                    if auto_search_all_sites "$normalized_input"; then
                        update_last_found_site "$CURRENT_PROFILE" "$SITE_ID" "$SITE_NAME"
                        site_id="$SITE_ID"
                        site_name="$SITE_NAME"
                        ap_serial="$AP_SERIAL"

                        log_info "Found in site: $site_name"
                        log_info ""

                        lookup_method="AUTOSEARCH"
                        goto_ap_details=true
                    else
                        log_error "Still not found after refreshing sites."
                        log_error "The device may be offline or not connected to any site."
                        exit "$EXIT_API_ERROR"
                    fi
                elif [[ "$response" =~ ^[Mm]$ ]]; then
                    # Manual site selection
                    select_site

                    if [[ "$SELECTED_SITE_ID" == "__REFRESH__" ]]; then
                        # User chose to refresh from the site menu
                        log_info "Refreshing sites cache..."
                        invalidate_sites_cache
                        fetch_and_cache_sites "$CURRENT_PROFILE"
                        load_cached_sites

                        # Show site selection again
                        select_site
                    fi

                    site_id="$SELECTED_SITE_ID"
                    site_name="$SELECTED_SITE_NAME"

                    # Continue to manual lookup in the selected site
                    # Don't set goto_ap_details=true, let it fall through to CLIENT/BSSID LOOKUP section
                else
                    # Exit
                    exit "$EXIT_API_ERROR"
                fi
            fi
        fi
    fi

    # === CLIENT/BSSID LOOKUP ===

    # Skip this section if we already found via auto-search
    if [[ "$goto_ap_details" != true ]]; then
        log_info ""
        log_info "Searching in site: $site_name"
        log_info ""

        local client_response lookup_method

        # Try 1: Lookup as client MAC
        log_info "Looking up: $normalized_input..."

        if client_response=$(get_client_by_mac "$normalized_input" "$site_id" 2>/dev/null); then
            # Display verbose client details FIRST (before validation)
            if [[ "$VERBOSE" == true ]]; then
                echo ""
                echo "Client Response:"
                echo "Raw response length: ${#client_response} bytes"
                if [[ -n "$client_response" ]]; then
                    echo "$client_response" | jq . 2>/dev/null || echo "$client_response"
                else
                    echo "(empty response)"
                fi
                echo ""
            fi

            # Success - extract serial
            ap_serial=$(echo "$client_response" | jq -r '.connectedDeviceSerial // empty')
            lookup_method="MAC"

            if [[ -z "$ap_serial" ]]; then
                log_error "Client found but no AP serial in response"
                exit "$EXIT_API_ERROR"
            fi

        else
            log_info "Client not found, trying as BSSID..."

            # Capture stdout while allowing the function to set global variables
            # Use a temp file to avoid subshell that would lose global variable assignments
            local temp_file
            temp_file=$(mktemp)
            if get_serial_by_bssid "$normalized_input" "$site_id" "$site_name" > "$temp_file"; then
                ap_serial=$(cat "$temp_file")
                rm -f "$temp_file"
                lookup_method="BSSID"
                log_info "Found by BSSID"
            else
                rm -f "$temp_file"
                log_error "$normalized_input not found in site '$site_name'"
                exit "$EXIT_API_ERROR"
            fi
        fi
    fi

    local ap_name ap_mac ap_ip ap_status down_reason

    if [[ "$lookup_method" == "BSSID" && "$VERIFY_AP_STATUS" != true ]]; then
        ap_name="$AP_NAME"
        ap_mac="$AP_MAC"
        ap_ip="$AP_IP"
        ap_status="ONLINE"
    else
        log_verbose ""
        log_verbose "Looking up AP $ap_serial..."

        local ap_response
        if ! ap_response=$(get_ap_by_serial "$ap_serial"); then
            if ! is_valid_json "$ap_response"; then
                log_error "Failed to look up AP $ap_serial - invalid response from server"
                log_verbose "Response: $ap_response"
            else
                log_error "Failed to look up AP $ap_serial"
                log_verbose "Response: $ap_response"
            fi
            exit "$EXIT_API_ERROR"
        fi

        if ! is_valid_json "$ap_response"; then
            log_error "AP lookup returned invalid response"
            log_verbose "Response: $ap_response"
            exit "$EXIT_API_ERROR"
        fi

        if echo "$ap_response" | jq -e '.error' &>/dev/null 2>&1; then
            local error_msg
            error_msg=$(echo "$ap_response" | jq -r '.error // "Unknown error"')
            log_error "AP lookup failed: $error_msg"
            exit "$EXIT_API_ERROR"
        fi

        if [[ "$VERBOSE" == true ]]; then
            echo ""
            echo "AP Response:"
            echo "$ap_response" | jq .
        fi

        ap_name=$(echo "$ap_response" | jq -r '.deviceName // "Unknown"')
        ap_mac=$(echo "$ap_response" | jq -r '.macAddress // "Unknown"')
        ap_ip=$(echo "$ap_response" | jq -r '.ipv4 // empty')
        ap_status=$(echo "$ap_response" | jq -r '.status // "Unknown"')
        down_reason=$(echo "$ap_response" | jq -r '.down_reason // ""')

        if [[ -z "$ap_ip" ]]; then
            log_error "AP found but no IP address available"
            exit "$EXIT_API_ERROR"
        fi
    fi

    if [[ "$lookup_method" == "MAC" ]]; then
        log_info "Client found on AP: $ap_name ($ap_mac) at $ap_ip"
    else
        log_info "BSSID found on AP: $ap_name ($ap_mac) at $ap_ip"
    fi

    # Warn if AP is down
    if [[ "$ap_status" == "Down" ]]; then
        log_info "WARNING: AP status is 'Down' (Reason: ${down_reason:-Unknown})"
        log_info "Attempting SSH anyway..."
    fi

    # Dry run check
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Dry run - not connecting. Would SSH to $SSH_USER@$ap_ip"
        exit "$EXIT_SUCCESS"
    fi

    # Get SSH password
    local password
    password=$(get_ssh_password)

    if [[ -z "$password" ]]; then
        log_error "No SSH password provided"
        exit "$EXIT_SSH_ERROR"
    fi

    # SSH to AP
    if ! ssh_to_ap "$ap_ip" "$password"; then
        exit "$EXIT_SSH_ERROR"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Site management commands
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmd_list_sites() {
    ensure_config_dir

    CURRENT_PROFILE="${PROFILE:-$(get_default_profile)}"
    load_profile "$CURRENT_PROFILE"

    if ! is_sites_cache_valid; then
        log_info "Cache expired, fetching sites..."
        fetch_and_cache_sites
    fi

    load_cached_sites

    local cache_file
    cache_file=$(get_sites_cache_file)
    local cache_time cache_timestamp
    # Get modification time in epoch format (cross-platform)
    if [[ "$(uname -s)" == "Darwin" ]]; then
        cache_timestamp=$(stat -f %m "$cache_file" 2>/dev/null)
    else
        cache_timestamp=$(stat -c %Y "$cache_file" 2>/dev/null)
    fi
    cache_time=$(date -d "@$cache_timestamp" 2>/dev/null || date -r "$cache_timestamp" 2>/dev/null || echo "unknown")

    echo ""
    echo "Cached sites (updated: $cache_time):"
    echo ""

    local hidden_count=0
    local visible_count=0

    for ((i=0; i<${#SITE_IDS[@]}; i++)); do
        if [[ "${SITE_CLIENT_COUNTS[$i]}" -gt 0 ]] || [[ "$SHOW_ALL_SITES" == true ]]; then
            printf "  %-35s (ID: %-18s, %3d clients)\n" \
                "${SITE_NAMES[$i]}" "${SITE_IDS[$i]}" "${SITE_CLIENT_COUNTS[$i]}"
            visible_count=$((visible_count + 1))
        else
            hidden_count=$((hidden_count + 1))
        fi
    done

    if [[ $hidden_count -gt 0 ]]; then
        echo ""
        echo "Note: $hidden_count sites have 0 clients (use --all to show or refresh the site cache)"
    fi

    if [[ $visible_count -eq 0 ]]; then
        echo "No sites with clients found. Use --all to see all sites."
    fi

    echo ""
}

cmd_refresh_sites() {
    ensure_config_dir

    CURRENT_PROFILE="${PROFILE:-$(get_default_profile)}"
    load_profile "$CURRENT_PROFILE"

    log_info "Refreshing site cache..."
    invalidate_sites_cache
    fetch_and_cache_sites

    log_info "Site cache refreshed"
    echo ""
    cmd_list_sites
}

cmd_list_aps() {
    ensure_config_dir

    CURRENT_PROFILE="${PROFILE:-$(get_default_profile)}"
    load_profile "$CURRENT_PROFILE"

    if [[ -z "$SITE_FILTER" && -z "$SITE_ID_FILTER" ]]; then
        log_error "The --list-aps command requires --site or --site-id"
        exit "$EXIT_ERROR"
    fi

    if ! is_sites_cache_valid; then
        log_info "Cache expired, fetching sites..."
        fetch_and_cache_sites
    fi

    load_cached_sites

    local site_id site_name
    if [[ -n "$SITE_ID_FILTER" ]]; then
        site_id="$SITE_ID_FILTER"
        site_name=$(find_site_by_id "$site_id")
        if [[ -z "$site_name" ]]; then
            log_error "Site ID '$site_id' not found"
            exit "$EXIT_ERROR"
        fi
    else
        site_id=$(find_site_by_name "$SITE_FILTER")
        if [[ -z "$site_id" ]]; then
            log_error "Site '$SITE_FILTER' not found"
            exit "$EXIT_ERROR"
        fi
        site_name="$SITE_FILTER"
    fi

    local cache_file
    cache_file=$(get_aps_cache_file "$site_id" "$site_name")

    if ! is_aps_cache_valid "$site_id" "$site_name"; then
        log_info "AP cache expired or missing, fetching..."
        if ! fetch_and_cache_aps "$site_id" "$site_name"; then
            log_error "Failed to fetch AP cache"
            exit "$EXIT_ERROR"
        fi
    fi

    local cache_time cache_timestamp
    # Get modification time in epoch format (cross-platform)
    if [[ "$(uname -s)" == "Darwin" ]]; then
        cache_timestamp=$(stat -f %m "$cache_file" 2>/dev/null)
    else
        cache_timestamp=$(stat -c %Y "$cache_file" 2>/dev/null)
    fi
    cache_time=$(date -d "@$cache_timestamp" 2>/dev/null || date -r "$cache_timestamp" 2>/dev/null || echo "unknown")

    echo ""
    echo "Cached APs for '$site_name' (updated: $cache_time):"
    echo ""

    while IFS='|' read -r serial name mac ip bssids; do
        [[ "$serial" =~ ^# ]] && continue
        printf "%-15s %-20s %-15s %s\n" "$serial" "$name" "$ip" "$bssids"
    done < <(grep -v '^#' "$cache_file")

    echo ""
}

cmd_refresh_aps() {
    ensure_config_dir

    CURRENT_PROFILE="${PROFILE:-$(get_default_profile)}"
    load_profile "$CURRENT_PROFILE"

    if [[ -z "$SITE_FILTER" && -z "$SITE_ID_FILTER" ]]; then
        log_error "The --refresh-aps command requires --site or --site-id"
        exit "$EXIT_ERROR"
    fi

    if ! is_sites_cache_valid; then
        log_info "Fetching sites..."
        fetch_and_cache_sites
    fi

    load_cached_sites

    local site_id site_name
    if [[ -n "$SITE_ID_FILTER" ]]; then
        site_id="$SITE_ID_FILTER"
        site_name=$(find_site_by_id "$site_id")
        if [[ -z "$site_name" ]]; then
            log_error "Site ID '$site_id' not found"
            exit "$EXIT_ERROR"
        fi
    else
        site_id=$(find_site_by_name "$SITE_FILTER")
        if [[ -z "$site_id" ]]; then
            log_error "Site '$SITE_FILTER' not found"
            exit "$EXIT_ERROR"
        fi
        site_name="$SITE_FILTER"
    fi

    log_info "Refreshing AP cache for '$site_name'..."
    invalidate_aps_cache "$site_id" "$site_name"

    if ! fetch_and_cache_aps "$site_id" "$site_name"; then
        log_error "Failed to refresh AP cache"
        exit "$EXIT_ERROR"
    fi

    log_info "AP cache refreshed"
    echo ""
    cmd_list_aps
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Help functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

show_help() {
    cat << EOF
$SCRIPT_NAME v$VERSION - Aruba New Central "Jump-to-AP" SSH tool

Quickly "hop" into the access point serving a wireless client by providing
only the client's MAC address or known AP BSSID.

USAGE:
    $SCRIPT_NAME [<mac|bssid>] [OPTIONS]
    $SCRIPT_NAME config [CONFIG_OPTIONS]
    $SCRIPT_NAME --list-sites [--all]
    $SCRIPT_NAME --refresh-sites
    $SCRIPT_NAME --list-aps --site <name>
    $SCRIPT_NAME --refresh-aps --site <name>

ARGUMENTS:
    <mac|bssid>    Client MAC address or BSSID (aa:bb:cc:dd:ee:ff, aa-bb-cc-dd-ee-ff, or aabbccddeeff)
                   If omitted, automatically detects and uses your devices Wi-Fi MAC address

GLOBAL OPTIONS:
    -h, --help              Show this help message
    --version               Show version

SITE & AP CACHE COMMANDS (standalone):
    --list-sites            Show cached sites and exit
    --refresh-sites         Force refresh site cache and exit
    --list-aps              Show cached APs (requires --site or --site-id)
    --refresh-aps           Force refresh AP cache (requires --site or --site-id)

MAC LOOKUP OPTIONS (used after MAC address):
    -p, --profile <name>    Use specified profile instead of default
    --site <name>           Search in specific site by name
    --site-id <id>          Search in specific site by ID
    --all                   Show all sites in interactive selection (not just those with clients)
    --verify                Verify AP status via API before SSH (slower, ensures current data)
    --non-interactive       Skip all prompts (useful for automation/scripting)
    -v, --verbose           Show raw JSON API responses
    -n, --dry-run           Query API and show results without connecting via SSH (auto-verbose)

Note: --site and --site-id can be used before or after MAC address, and also work with
      cache commands (--list-aps, --refresh-aps)

CONFIG SUBCOMMAND:
    $SCRIPT_NAME config                               Interactive setup
    $SCRIPT_NAME config --profile <name>              Configure named profile
    $SCRIPT_NAME config --show [--unmask]             Show active profile
    $SCRIPT_NAME config --list                        List all profiles
    $SCRIPT_NAME config --use <name>                  Set default profile
    $SCRIPT_NAME config --delete --profile <name>     Delete a profile

EXAMPLES:
    # Basic lookup
    $SCRIPT_NAME                                      # Auto-detect local Wi-Fi
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff                    # Interactive site selection

    # BSSID lookup
    $SCRIPT_NAME 68:51:34:7c:32:10                   # BSSID lookup
    $SCRIPT_NAME 68:51:34:7c:32:10 --verify          # With API verification

    # Site selection
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --site "Twede's Cafe"
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --site-id 51101706940
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --all             # Show all sites including empty ones

    # Profile and options
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --profile prod
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --verbose         # Show API responses
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --dry-run         # Test without SSH

    # Combining options (flags after MAC address)
    $SCRIPT_NAME aa:bb:cc:dd:ee:ff --site "The Grid" --profile prod --verbose

    # Site and AP cache management
    $SCRIPT_NAME --list-sites                        # Show available sites
    $SCRIPT_NAME --list-sites --all                  # Include sites with 0 clients
    $SCRIPT_NAME --refresh-sites                     # Update site cache
    $SCRIPT_NAME --list-aps --site "Twede's Cafe"    # Show APs in site
    $SCRIPT_NAME --refresh-aps --site "Twede's Cafe" 

    # Config management
    $SCRIPT_NAME config                              # Interactive setup
    $SCRIPT_NAME config --use prod                   # Set default profile

ENVIRONMENT VARIABLES:
    ARUBA_SSH_PASSWORD      SSH password (if not in config)
    XDG_CONFIG_HOME         Config directory base (default: ~/.config)

FILES:
    \$XDG_CONFIG_HOME/$SCRIPT_NAME/config          Profile configuration
    \$XDG_CONFIG_HOME/$SCRIPT_NAME/clusters        Cluster URL definitions
    \$XDG_CONFIG_HOME/$SCRIPT_NAME/sites_cache     Site cache (24hr TTL)
    \$XDG_CONFIG_HOME/$SCRIPT_NAME/aps_cache_*     AP cache per site (24hr TTL)

EOF
}

show_config_help() {
    cat << EOF
$SCRIPT_NAME config - Manage profile configuration

USAGE:
    $SCRIPT_NAME config [OPTIONS]

OPTIONS:
    --profile <name>, -p    Specify profile to operate on
    --show                  Show profile configuration (secrets masked)
    --unmask                Show sensitive values when used with --show
    --list                  List all available profiles
    --use <name>            Set the default profile
    --delete                Delete profile (requires --profile)
    -h, --help              Show this help message

EXAMPLES:
    $SCRIPT_NAME config                              # Interactive setup
    $SCRIPT_NAME config --profile production         # Configure 'production' profile
    $SCRIPT_NAME config --show                       # Show active profile (masked)
    $SCRIPT_NAME config --show --unmask              # Show active profile (unmasked)
    $SCRIPT_NAME config --show --profile prod        # Show 'prod' profile
    $SCRIPT_NAME config --list                       # List all profiles
    $SCRIPT_NAME config --use production             # Set 'production' as default
    $SCRIPT_NAME config --delete --profile old       # Delete 'old' profile

EOF
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Main
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

main() {
    # Parse global options (stop at first positional argument)
    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--profile)
                if [[ -z "${2:-}" ]]; then
                    log_error "--profile requires a profile name"
                    exit "$EXIT_ERROR"
                fi
                PROFILE="$2"
                shift 2
                ;;
            --site)
                if [[ -z "${2:-}" ]]; then
                    log_error "--site requires a site name"
                    exit "$EXIT_ERROR"
                fi
                SITE_FILTER="$2"
                shift 2
                ;;
            --site-id)
                if [[ -z "${2:-}" ]]; then
                    log_error "--site-id requires a site ID"
                    exit "$EXIT_ERROR"
                fi
                SITE_ID_FILTER="$2"
                shift 2
                ;;
            --list-sites)
                LIST_SITES=true
                shift
                ;;
            --refresh-sites)
                REFRESH_SITES=true
                shift
                ;;
            --list-aps)
                LIST_APS=true
                shift
                ;;
            --refresh-aps)
                REFRESH_APS=true
                shift
                ;;
            --all)
                SHOW_ALL_SITES=true
                shift
                ;;
            --verify)
                VERIFY_AP_STATUS=true
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                VERBOSE=true  # Dry-run is automatically verbose
                shift
                ;;
            -h|--help)
                show_help
                exit "$EXIT_SUCCESS"
                ;;
            --version)
                echo "$SCRIPT_NAME v$VERSION"
                exit "$EXIT_SUCCESS"
                ;;
            --)
                shift
                positional_args+=("$@")
                break
                ;;
            -*)
                # Unknown option - might be for subcommand, collect remaining args
                positional_args+=("$@")
                break
                ;;
            *)
                # First positional argument found - collect it and all remaining args
                positional_args+=("$@")
                break
                ;;
        esac
    done

    # Check dependencies
    check_dependencies

    # Ensure config directory and files exist
    ensure_config_dir
    ensure_clusters_file
    ensure_config_file

    # Handle --list-sites and --refresh-sites commands
    if [[ "$LIST_SITES" == true ]]; then
        cmd_list_sites
        exit "$EXIT_SUCCESS"
    fi

    if [[ "$REFRESH_SITES" == true ]]; then
        cmd_refresh_sites
        exit "$EXIT_SUCCESS"
    fi

    # Handle --list-aps and --refresh-aps commands
    if [[ "$LIST_APS" == true ]]; then
        cmd_list_aps
        exit "$EXIT_SUCCESS"
    fi

    if [[ "$REFRESH_APS" == true ]]; then
        cmd_refresh_aps
        exit "$EXIT_SUCCESS"
    fi

    # Handle subcommands or MAC address
    if [[ ${#positional_args[@]} -eq 0 ]]; then
        # No arguments provided - assume we're trying to jump to the AP we're currently connected to
        log_info "No target MAC address provided, looking for your devices Wi-Fi connection..."

        local local_mac
        if local_mac=$(get_local_wifi_mac); then
            log_info "Detected local Wi-Fi MAC: $local_mac"
            log_info ""
            positional_args=("$local_mac")
        else
            echo "" >&2
            echo "Not connected to Wi-Fi." >&2
            echo "Run '$SCRIPT_NAME -h' for options." >&2
            echo "" >&2
            exit "$EXIT_ERROR"
        fi
    fi

    local first_arg="${positional_args[0]}"

    if [[ "$first_arg" == "config" ]]; then
        # Config subcommand
        if [[ ${#positional_args[@]} -gt 1 ]]; then
            cmd_config "${positional_args[@]:1}"
        else
            cmd_config
        fi
    elif validate_mac "$first_arg"; then
        # MAC/BSSID address provided - parse any remaining options
        if [[ ${#positional_args[@]} -gt 1 ]]; then
            local remaining_args=("${positional_args[@]:1}")
            local i=0
            while [[ $i -lt ${#remaining_args[@]} ]]; do
                case "${remaining_args[$i]}" in
                    -p|--profile)
                        if [[ $((i + 1)) -ge ${#remaining_args[@]} ]]; then
                            log_error "--profile requires a profile name"
                            exit "$EXIT_ERROR"
                        fi
                        PROFILE="${remaining_args[$((i + 1))]}"
                        i=$((i + 2))
                        ;;
                    --site)
                        if [[ $((i + 1)) -ge ${#remaining_args[@]} ]]; then
                            log_error "--site requires a site name"
                            exit "$EXIT_ERROR"
                        fi
                        SITE_FILTER="${remaining_args[$((i + 1))]}"
                        i=$((i + 2))
                        ;;
                    --site-id)
                        if [[ $((i + 1)) -ge ${#remaining_args[@]} ]]; then
                            log_error "--site-id requires a site ID"
                            exit "$EXIT_ERROR"
                        fi
                        SITE_ID_FILTER="${remaining_args[$((i + 1))]}"
                        i=$((i + 2))
                        ;;
                    --all)
                        SHOW_ALL_SITES=true
                        i=$((i + 1))
                        ;;
                    --verify)
                        VERIFY_AP_STATUS=true
                        i=$((i + 1))
                        ;;
                    --non-interactive)
                        NON_INTERACTIVE=true
                        i=$((i + 1))
                        ;;
                    -v|--verbose)
                        VERBOSE=true
                        i=$((i + 1))
                        ;;
                    -n|--dry-run)
                        DRY_RUN=true
                        VERBOSE=true
                        i=$((i + 1))
                        ;;
                    -*)
                        log_error "Unknown option: ${remaining_args[$i]}"
                        exit "$EXIT_ERROR"
                        ;;
                    *)
                        log_error "Unexpected argument: ${remaining_args[$i]}"
                        exit "$EXIT_ERROR"
                        ;;
                esac
            done
        fi
        cmd_lookup "$first_arg"
    else
        log_error "Invalid MAC address: $first_arg"
        log_error "Accepted formats: aa:bb:cc:dd:ee:ff, aa-bb-cc-dd-ee-ff, aabbccddeeff"
        exit "$EXIT_VALIDATION_ERROR"
    fi
}

main "$@"
